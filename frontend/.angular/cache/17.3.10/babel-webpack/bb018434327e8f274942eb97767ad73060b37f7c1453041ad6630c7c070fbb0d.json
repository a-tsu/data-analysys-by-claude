{"ast":null,"code":"/**\n * This file is responsible for building the DOM and updating DOM state.\n *\n * @author Tim Scanlin\n */\n\nexport default function (options) {\n  const forEach = [].forEach;\n  const some = [].some;\n  const body = typeof window !== \"undefined\" && document.body;\n  const SPACE_CHAR = \" \";\n  let tocElement;\n  let currentlyHighlighting = true;\n  let eventCount = 0;\n\n  /**\n   * Create link and list elements.\n   * @param {Object} d\n   * @param {HTMLElement} container\n   * @return {HTMLElement}\n   */\n  function createEl(d, container) {\n    const link = container.appendChild(createLink(d));\n    if (d.children.length) {\n      const list = createList(d.isCollapsed);\n      d.children.forEach(child => {\n        createEl(child, list);\n      });\n      link.appendChild(list);\n    }\n  }\n\n  /**\n   * Render nested heading array data into a given element.\n   * @param {HTMLElement} parent Optional. If provided updates the {@see tocElement} to match.\n   * @param {Array} data\n   * @return {HTMLElement}\n   */\n  function render(parent, data) {\n    const collapsed = false;\n    const container = createList(collapsed);\n    data.forEach(d => {\n      createEl(d, container);\n    });\n\n    // Return if no TOC element is provided or known.\n    tocElement = parent || tocElement;\n    if (tocElement === null) {\n      return;\n    }\n\n    // Remove existing child if it exists.\n    if (tocElement.firstChild) {\n      tocElement.removeChild(tocElement.firstChild);\n    }\n\n    // Just return the parent and don't append the list if no links are found.\n    if (data.length === 0) {\n      return tocElement;\n    }\n\n    // Append the Elements that have been created\n    return tocElement.appendChild(container);\n  }\n\n  /**\n   * Create link element.\n   * @param {Object} data\n   * @return {HTMLElement}\n   */\n  function createLink(data) {\n    const item = document.createElement(\"li\");\n    const a = document.createElement(\"a\");\n    if (options.listItemClass) {\n      item.setAttribute(\"class\", options.listItemClass);\n    }\n    if (options.onClick) {\n      a.onclick = options.onClick;\n    }\n    if (options.includeTitleTags) {\n      a.setAttribute(\"title\", data.textContent);\n    }\n    if (options.includeHtml && data.childNodes.length) {\n      forEach.call(data.childNodes, node => {\n        a.appendChild(node.cloneNode(true));\n      });\n    } else {\n      // Default behavior. Set to textContent to keep tests happy.\n      a.textContent = data.textContent;\n    }\n    a.setAttribute(\"href\", `${options.basePath}#${data.id}`);\n    a.setAttribute(\"class\", `${options.linkClass + SPACE_CHAR}node-name--${data.nodeName}${SPACE_CHAR}${options.extraLinkClasses}`);\n    item.appendChild(a);\n    return item;\n  }\n\n  /**\n   * Create list element.\n   * @param {Boolean} isCollapsed\n   * @return {HTMLElement}\n   */\n  function createList(isCollapsed) {\n    const listElement = options.orderedList ? \"ol\" : \"ul\";\n    const list = document.createElement(listElement);\n    let classes = options.listClass + SPACE_CHAR + options.extraListClasses;\n    if (isCollapsed) {\n      // No plus/equals here fixes compilation issue.\n      classes = classes + SPACE_CHAR + options.collapsibleClass;\n      classes = classes + SPACE_CHAR + options.isCollapsedClass;\n    }\n    list.setAttribute(\"class\", classes);\n    return list;\n  }\n\n  /**\n   * Update fixed sidebar class.\n   * @return {HTMLElement}\n   */\n  function updateFixedSidebarClass() {\n    const scrollTop = getScrollTop();\n    const posFixedEl = document.querySelector(options.positionFixedSelector);\n    if (options.fixedSidebarOffset === \"auto\") {\n      options.fixedSidebarOffset = tocElement.offsetTop;\n    }\n    if (scrollTop > options.fixedSidebarOffset) {\n      if (posFixedEl.className.indexOf(options.positionFixedClass) === -1) {\n        posFixedEl.className += SPACE_CHAR + options.positionFixedClass;\n      }\n    } else {\n      posFixedEl.className = posFixedEl.className.replace(SPACE_CHAR + options.positionFixedClass, \"\");\n    }\n  }\n\n  /**\n   * Get top position of heading\n   * @param {HTMLElement} obj\n   * @return {int} position\n   */\n  function getHeadingTopPos(obj) {\n    let position = 0;\n    if (obj !== null) {\n      position = obj.offsetTop;\n      if (options.hasInnerContainers) {\n        position += getHeadingTopPos(obj.offsetParent);\n      }\n    }\n    return position;\n  }\n\n  /**\n   * Update className only when changed.\n   * @param {HTMLElement} obj\n   * @param {string} className\n   * @return {HTMLElement} obj\n   */\n  function updateClassname(obj, className) {\n    if (obj && obj.className !== className) {\n      obj.className = className;\n    }\n    return obj;\n  }\n\n  /**\n   * Update TOC highlighting and collapsed groupings.\n   */\n  function updateToc(headingsArray, event) {\n    // Add fixed class at offset\n    if (options.positionFixedSelector) {\n      updateFixedSidebarClass();\n    }\n    // Get the top most heading currently visible on the page so we know what to highlight.\n    const headings = headingsArray;\n    // This is needed for scroll events since document doesn't have getAttribute\n    const clickedHref = event?.target?.getAttribute ? event?.target?.getAttribute(\"href\") : null;\n    const isBottomMode = clickedHref && clickedHref.charAt(0) === \"#\" ? getIsHeaderBottomMode(clickedHref.replace(\"#\", \"\")) : false;\n    const shouldUpdate = currentlyHighlighting || isBottomMode;\n    if (event && eventCount < 5) {\n      eventCount++;\n    }\n    if (shouldUpdate && !!tocElement && headings.length > 0) {\n      const topHeader = getTopHeader(headings);\n      const oldActiveTocLink = tocElement.querySelector(`.${options.activeLinkClass}`);\n      const topHeaderId = topHeader.id.replace(/([ #;&,.+*~':\"!^$[\\]()=>|/\\\\@])/g, \"\\\\$1\");\n      const hashId = window.location.hash.replace(\"#\", \"\");\n      let activeId = topHeaderId;\n\n      // Handle case where they clicked a link that cannot be scrolled to.\n      const isPageBottomMode = getIsPageBottomMode();\n      if (clickedHref && isBottomMode) {\n        activeId = clickedHref.replace(\"#\", \"\");\n      } else if (hashId && hashId !== topHeaderId && isPageBottomMode && (getIsHeaderBottomMode(topHeaderId) || eventCount <= 2)) {\n        // This is meant to handle the case\n        // of showing the items as highlighted when they\n        // are in bottom mode and cannot be scrolled to.\n        // Make sure that they stay highlighted on refresh\n        // too, not just when clicked.\n        activeId = hashId;\n      }\n      const activeTocLink = tocElement.querySelector(`.${options.linkClass}[href=\"${options.basePath}#${activeId}\"]`);\n      // Performance improvement to only change the classes\n      // for the toc if a new link should be highlighted.\n      if (oldActiveTocLink === activeTocLink) {\n        return;\n      }\n\n      // Remove the active class from the other tocLinks.\n      const tocLinks = tocElement.querySelectorAll(`.${options.linkClass}`);\n      forEach.call(tocLinks, tocLink => {\n        updateClassname(tocLink, tocLink.className.replace(SPACE_CHAR + options.activeLinkClass, \"\"));\n      });\n      const tocLis = tocElement.querySelectorAll(`.${options.listItemClass}`);\n      forEach.call(tocLis, tocLi => {\n        updateClassname(tocLi, tocLi.className.replace(SPACE_CHAR + options.activeListItemClass, \"\"));\n      });\n\n      // Add the active class to the active tocLink.\n      if (activeTocLink && activeTocLink.className.indexOf(options.activeLinkClass) === -1) {\n        activeTocLink.className += SPACE_CHAR + options.activeLinkClass;\n      }\n      const li = activeTocLink?.parentNode;\n      if (li && li.className.indexOf(options.activeListItemClass) === -1) {\n        li.className += SPACE_CHAR + options.activeListItemClass;\n      }\n      const tocLists = tocElement.querySelectorAll(`.${options.listClass}.${options.collapsibleClass}`);\n\n      // Collapse the other collapsible lists.\n      forEach.call(tocLists, list => {\n        if (list.className.indexOf(options.isCollapsedClass) === -1) {\n          list.className += SPACE_CHAR + options.isCollapsedClass;\n        }\n      });\n\n      // Expand the active link's collapsible list and its sibling if applicable.\n      if (activeTocLink?.nextSibling && activeTocLink.nextSibling.className.indexOf(options.isCollapsedClass) !== -1) {\n        updateClassname(activeTocLink.nextSibling, activeTocLink.nextSibling.className.replace(SPACE_CHAR + options.isCollapsedClass, \"\"));\n      }\n      removeCollapsedFromParents(activeTocLink?.parentNode.parentNode);\n    }\n  }\n\n  /**\n   * Remove collapsed class from parent elements.\n   * @param {HTMLElement} element\n   * @return {HTMLElement}\n   */\n  function removeCollapsedFromParents(element) {\n    if (element && element.className.indexOf(options.collapsibleClass) !== -1 && element.className.indexOf(options.isCollapsedClass) !== -1) {\n      updateClassname(element, element.className.replace(SPACE_CHAR + options.isCollapsedClass, \"\"));\n      return removeCollapsedFromParents(element.parentNode.parentNode);\n    }\n    return element;\n  }\n\n  /**\n   * Disable TOC Animation when a link is clicked.\n   * @param {Event} event\n   */\n  function disableTocAnimation(event) {\n    const target = event.target || event.srcElement;\n    if (typeof target.className !== \"string\" || target.className.indexOf(options.linkClass) === -1) {\n      return;\n    }\n    // Bind to tocLink clicks to temporarily disable highlighting\n    // while smoothScroll is animating.\n    currentlyHighlighting = false;\n  }\n\n  /**\n   * Enable TOC Animation.\n   */\n  function enableTocAnimation() {\n    currentlyHighlighting = true;\n  }\n\n  /**\n   * Return currently highlighting status.\n   */\n  function getCurrentlyHighlighting() {\n    return currentlyHighlighting;\n  }\n  function getIsHeaderBottomMode(headerId) {\n    const scrollEl = getScrollEl();\n    const activeHeading = document?.getElementById(headerId);\n    const isBottomMode = activeHeading.offsetTop > scrollEl.offsetHeight - scrollEl.clientHeight * 1.4 - options.bottomModeThreshold;\n    return isBottomMode;\n  }\n  function getIsPageBottomMode() {\n    const scrollEl = getScrollEl();\n    const isScrollable = scrollEl.scrollHeight > scrollEl.clientHeight;\n    const isBottomMode = getScrollTop() + scrollEl.clientHeight > scrollEl.offsetHeight - options.bottomModeThreshold;\n    return isScrollable && isBottomMode;\n  }\n  function getScrollEl() {\n    let el;\n    if (options.scrollContainer && document.querySelector(options.scrollContainer)) {\n      el = document.querySelector(options.scrollContainer);\n    } else {\n      el = document.documentElement || body;\n    }\n    return el;\n  }\n  function getScrollTop() {\n    const el = getScrollEl();\n    return el?.scrollTop || 0;\n  }\n  function getTopHeader(headings, scrollTop = getScrollTop()) {\n    let topHeader;\n    some.call(headings, (heading, i) => {\n      if (getHeadingTopPos(heading) > scrollTop + options.headingsOffset + 10) {\n        // Don't allow negative index value.\n        const index = i === 0 ? i : i - 1;\n        topHeader = headings[index];\n        return true;\n      }\n      if (i === headings.length - 1) {\n        // This allows scrolling for the last heading on the page.\n        topHeader = headings[headings.length - 1];\n        return true;\n      }\n    });\n    return topHeader;\n  }\n  function updateUrlHashForHeader(headingsArray) {\n    const scrollTop = getScrollTop();\n    const topHeader = getTopHeader(headingsArray, scrollTop);\n    const isPageBottomMode = getIsPageBottomMode();\n    if ((!topHeader || scrollTop < 5) && !isPageBottomMode) {\n      if (!(window.location.hash === \"#\" || window.location.hash === \"\")) {\n        window.history.pushState(null, null, \"#\");\n      }\n    } else if (topHeader && !isPageBottomMode) {\n      const newHash = `#${topHeader.id}`;\n      if (window.location.hash !== newHash) {\n        window.history.pushState(null, null, newHash);\n      }\n    }\n  }\n  return {\n    enableTocAnimation,\n    disableTocAnimation,\n    render,\n    updateToc,\n    getCurrentlyHighlighting,\n    getTopHeader,\n    getScrollTop,\n    updateUrlHashForHeader\n  };\n}","map":{"version":3,"names":["options","forEach","some","body","window","document","SPACE_CHAR","tocElement","currentlyHighlighting","eventCount","createEl","d","container","link","appendChild","createLink","children","length","list","createList","isCollapsed","child","render","parent","data","collapsed","firstChild","removeChild","item","createElement","a","listItemClass","setAttribute","onClick","onclick","includeTitleTags","textContent","includeHtml","childNodes","call","node","cloneNode","basePath","id","linkClass","nodeName","extraLinkClasses","listElement","orderedList","classes","listClass","extraListClasses","collapsibleClass","isCollapsedClass","updateFixedSidebarClass","scrollTop","getScrollTop","posFixedEl","querySelector","positionFixedSelector","fixedSidebarOffset","offsetTop","className","indexOf","positionFixedClass","replace","getHeadingTopPos","obj","position","hasInnerContainers","offsetParent","updateClassname","updateToc","headingsArray","event","headings","clickedHref","target","getAttribute","isBottomMode","charAt","getIsHeaderBottomMode","shouldUpdate","topHeader","getTopHeader","oldActiveTocLink","activeLinkClass","topHeaderId","hashId","location","hash","activeId","isPageBottomMode","getIsPageBottomMode","activeTocLink","tocLinks","querySelectorAll","tocLink","tocLis","tocLi","activeListItemClass","li","parentNode","tocLists","nextSibling","removeCollapsedFromParents","element","disableTocAnimation","srcElement","enableTocAnimation","getCurrentlyHighlighting","headerId","scrollEl","getScrollEl","activeHeading","getElementById","offsetHeight","clientHeight","bottomModeThreshold","isScrollable","scrollHeight","el","scrollContainer","documentElement","heading","i","headingsOffset","index","updateUrlHashForHeader","history","pushState","newHash"],"sources":["/home/a-tsu/data-analysys-by-claude/frontend/node_modules/tocbot/src/js/build-html.js"],"sourcesContent":["/**\n * This file is responsible for building the DOM and updating DOM state.\n *\n * @author Tim Scanlin\n */\n\nexport default function (options) {\n  const forEach = [].forEach\n  const some = [].some\n  const body = typeof window !== \"undefined\" && document.body\n  const SPACE_CHAR = \" \"\n  let tocElement\n  let currentlyHighlighting = true\n  let eventCount = 0\n\n  /**\n   * Create link and list elements.\n   * @param {Object} d\n   * @param {HTMLElement} container\n   * @return {HTMLElement}\n   */\n  function createEl(d, container) {\n    const link = container.appendChild(createLink(d))\n    if (d.children.length) {\n      const list = createList(d.isCollapsed)\n      d.children.forEach((child) => {\n        createEl(child, list)\n      })\n      link.appendChild(list)\n    }\n  }\n\n  /**\n   * Render nested heading array data into a given element.\n   * @param {HTMLElement} parent Optional. If provided updates the {@see tocElement} to match.\n   * @param {Array} data\n   * @return {HTMLElement}\n   */\n  function render(parent, data) {\n    const collapsed = false\n    const container = createList(collapsed)\n\n    data.forEach((d) => {\n      createEl(d, container)\n    })\n\n    // Return if no TOC element is provided or known.\n    tocElement = parent || tocElement\n    if (tocElement === null) {\n      return\n    }\n\n    // Remove existing child if it exists.\n    if (tocElement.firstChild) {\n      tocElement.removeChild(tocElement.firstChild)\n    }\n\n    // Just return the parent and don't append the list if no links are found.\n    if (data.length === 0) {\n      return tocElement\n    }\n\n    // Append the Elements that have been created\n    return tocElement.appendChild(container)\n  }\n\n  /**\n   * Create link element.\n   * @param {Object} data\n   * @return {HTMLElement}\n   */\n  function createLink(data) {\n    const item = document.createElement(\"li\")\n    const a = document.createElement(\"a\")\n    if (options.listItemClass) {\n      item.setAttribute(\"class\", options.listItemClass)\n    }\n\n    if (options.onClick) {\n      a.onclick = options.onClick\n    }\n\n    if (options.includeTitleTags) {\n      a.setAttribute(\"title\", data.textContent)\n    }\n\n    if (options.includeHtml && data.childNodes.length) {\n      forEach.call(data.childNodes, (node) => {\n        a.appendChild(node.cloneNode(true))\n      })\n    } else {\n      // Default behavior. Set to textContent to keep tests happy.\n      a.textContent = data.textContent\n    }\n    a.setAttribute(\"href\", `${options.basePath}#${data.id}`)\n    a.setAttribute(\n      \"class\",\n      `${\n        options.linkClass + SPACE_CHAR\n      }node-name--${data.nodeName}${SPACE_CHAR}${options.extraLinkClasses}`,\n    )\n    item.appendChild(a)\n    return item\n  }\n\n  /**\n   * Create list element.\n   * @param {Boolean} isCollapsed\n   * @return {HTMLElement}\n   */\n  function createList(isCollapsed) {\n    const listElement = options.orderedList ? \"ol\" : \"ul\"\n    const list = document.createElement(listElement)\n    let classes = options.listClass + SPACE_CHAR + options.extraListClasses\n    if (isCollapsed) {\n      // No plus/equals here fixes compilation issue.\n      classes = classes + SPACE_CHAR + options.collapsibleClass\n      classes = classes + SPACE_CHAR + options.isCollapsedClass\n    }\n    list.setAttribute(\"class\", classes)\n    return list\n  }\n\n  /**\n   * Update fixed sidebar class.\n   * @return {HTMLElement}\n   */\n  function updateFixedSidebarClass() {\n    const scrollTop = getScrollTop()\n\n    const posFixedEl = document.querySelector(options.positionFixedSelector)\n    if (options.fixedSidebarOffset === \"auto\") {\n      options.fixedSidebarOffset = tocElement.offsetTop\n    }\n\n    if (scrollTop > options.fixedSidebarOffset) {\n      if (posFixedEl.className.indexOf(options.positionFixedClass) === -1) {\n        posFixedEl.className += SPACE_CHAR + options.positionFixedClass\n      }\n    } else {\n      posFixedEl.className = posFixedEl.className.replace(\n        SPACE_CHAR + options.positionFixedClass,\n        \"\",\n      )\n    }\n  }\n\n  /**\n   * Get top position of heading\n   * @param {HTMLElement} obj\n   * @return {int} position\n   */\n  function getHeadingTopPos(obj) {\n    let position = 0\n    if (obj !== null) {\n      position = obj.offsetTop\n      if (options.hasInnerContainers) {\n        position += getHeadingTopPos(obj.offsetParent)\n      }\n    }\n    return position\n  }\n\n  /**\n   * Update className only when changed.\n   * @param {HTMLElement} obj\n   * @param {string} className\n   * @return {HTMLElement} obj\n   */\n  function updateClassname(obj, className) {\n    if (obj && obj.className !== className) {\n      obj.className = className\n    }\n    return obj\n  }\n\n  /**\n   * Update TOC highlighting and collapsed groupings.\n   */\n  function updateToc(headingsArray, event) {\n    // Add fixed class at offset\n    if (options.positionFixedSelector) {\n      updateFixedSidebarClass()\n    }\n    // Get the top most heading currently visible on the page so we know what to highlight.\n    const headings = headingsArray\n    // This is needed for scroll events since document doesn't have getAttribute\n    const clickedHref = event?.target?.getAttribute\n      ? event?.target?.getAttribute(\"href\")\n      : null\n    const isBottomMode =\n      clickedHref && clickedHref.charAt(0) === \"#\"\n        ? getIsHeaderBottomMode(clickedHref.replace(\"#\", \"\"))\n        : false\n    const shouldUpdate = currentlyHighlighting || isBottomMode\n    if (event && eventCount < 5) {\n      eventCount++\n    }\n\n    if (shouldUpdate && !!tocElement && headings.length > 0) {\n      const topHeader = getTopHeader(headings)\n\n      const oldActiveTocLink = tocElement.querySelector(\n        `.${options.activeLinkClass}`,\n      )\n\n      const topHeaderId = topHeader.id.replace(\n        /([ #;&,.+*~':\"!^$[\\]()=>|/\\\\@])/g,\n        \"\\\\$1\",\n      )\n      const hashId = window.location.hash.replace(\"#\", \"\")\n      let activeId = topHeaderId\n\n      // Handle case where they clicked a link that cannot be scrolled to.\n      const isPageBottomMode = getIsPageBottomMode()\n      if (clickedHref && isBottomMode) {\n        activeId = clickedHref.replace(\"#\", \"\")\n      } else if (\n        hashId &&\n        hashId !== topHeaderId &&\n        isPageBottomMode &&\n        (getIsHeaderBottomMode(topHeaderId) || eventCount <= 2)\n      ) {\n        // This is meant to handle the case\n        // of showing the items as highlighted when they\n        // are in bottom mode and cannot be scrolled to.\n        // Make sure that they stay highlighted on refresh\n        // too, not just when clicked.\n        activeId = hashId\n      }\n\n      const activeTocLink = tocElement.querySelector(\n        `.${options.linkClass}[href=\"${options.basePath}#${activeId}\"]`,\n      )\n      // Performance improvement to only change the classes\n      // for the toc if a new link should be highlighted.\n      if (oldActiveTocLink === activeTocLink) {\n        return\n      }\n\n      // Remove the active class from the other tocLinks.\n      const tocLinks = tocElement.querySelectorAll(`.${options.linkClass}`)\n      forEach.call(tocLinks, (tocLink) => {\n        updateClassname(\n          tocLink,\n          tocLink.className.replace(SPACE_CHAR + options.activeLinkClass, \"\"),\n        )\n      })\n      const tocLis = tocElement.querySelectorAll(`.${options.listItemClass}`)\n      forEach.call(tocLis, (tocLi) => {\n        updateClassname(\n          tocLi,\n          tocLi.className.replace(SPACE_CHAR + options.activeListItemClass, \"\"),\n        )\n      })\n\n      // Add the active class to the active tocLink.\n      if (\n        activeTocLink &&\n        activeTocLink.className.indexOf(options.activeLinkClass) === -1\n      ) {\n        activeTocLink.className += SPACE_CHAR + options.activeLinkClass\n      }\n      const li = activeTocLink?.parentNode\n      if (li && li.className.indexOf(options.activeListItemClass) === -1) {\n        li.className += SPACE_CHAR + options.activeListItemClass\n      }\n\n      const tocLists = tocElement.querySelectorAll(\n        `.${options.listClass}.${options.collapsibleClass}`,\n      )\n\n      // Collapse the other collapsible lists.\n      forEach.call(tocLists, (list) => {\n        if (list.className.indexOf(options.isCollapsedClass) === -1) {\n          list.className += SPACE_CHAR + options.isCollapsedClass\n        }\n      })\n\n      // Expand the active link's collapsible list and its sibling if applicable.\n      if (\n        activeTocLink?.nextSibling &&\n        activeTocLink.nextSibling.className.indexOf(\n          options.isCollapsedClass,\n        ) !== -1\n      ) {\n        updateClassname(\n          activeTocLink.nextSibling,\n          activeTocLink.nextSibling.className.replace(\n            SPACE_CHAR + options.isCollapsedClass,\n            \"\",\n          ),\n        )\n      }\n      removeCollapsedFromParents(activeTocLink?.parentNode.parentNode)\n    }\n  }\n\n  /**\n   * Remove collapsed class from parent elements.\n   * @param {HTMLElement} element\n   * @return {HTMLElement}\n   */\n  function removeCollapsedFromParents(element) {\n    if (\n      element &&\n      element.className.indexOf(options.collapsibleClass) !== -1 &&\n      element.className.indexOf(options.isCollapsedClass) !== -1\n    ) {\n      updateClassname(\n        element,\n        element.className.replace(SPACE_CHAR + options.isCollapsedClass, \"\"),\n      )\n      return removeCollapsedFromParents(element.parentNode.parentNode)\n    }\n    return element\n  }\n\n  /**\n   * Disable TOC Animation when a link is clicked.\n   * @param {Event} event\n   */\n  function disableTocAnimation(event) {\n    const target = event.target || event.srcElement\n    if (\n      typeof target.className !== \"string\" ||\n      target.className.indexOf(options.linkClass) === -1\n    ) {\n      return\n    }\n    // Bind to tocLink clicks to temporarily disable highlighting\n    // while smoothScroll is animating.\n    currentlyHighlighting = false\n  }\n\n  /**\n   * Enable TOC Animation.\n   */\n  function enableTocAnimation() {\n    currentlyHighlighting = true\n  }\n\n  /**\n   * Return currently highlighting status.\n   */\n  function getCurrentlyHighlighting() {\n    return currentlyHighlighting\n  }\n\n  function getIsHeaderBottomMode(headerId) {\n    const scrollEl = getScrollEl()\n    const activeHeading = document?.getElementById(headerId)\n    const isBottomMode =\n      activeHeading.offsetTop >\n      scrollEl.offsetHeight -\n        scrollEl.clientHeight * 1.4 -\n        options.bottomModeThreshold\n    return isBottomMode\n  }\n\n  function getIsPageBottomMode() {\n    const scrollEl = getScrollEl()\n    const isScrollable = scrollEl.scrollHeight > scrollEl.clientHeight\n    const isBottomMode =\n      getScrollTop() + scrollEl.clientHeight >\n      scrollEl.offsetHeight - options.bottomModeThreshold\n    return isScrollable && isBottomMode\n  }\n\n  function getScrollEl() {\n    let el\n    if (\n      options.scrollContainer &&\n      document.querySelector(options.scrollContainer)\n    ) {\n      el = document.querySelector(options.scrollContainer)\n    } else {\n      el = document.documentElement || body\n    }\n    return el\n  }\n\n  function getScrollTop() {\n    const el = getScrollEl()\n    return el?.scrollTop || 0\n  }\n\n  function getTopHeader(headings, scrollTop = getScrollTop()) {\n    let topHeader\n    some.call(headings, (heading, i) => {\n      if (getHeadingTopPos(heading) > scrollTop + options.headingsOffset + 10) {\n        // Don't allow negative index value.\n        const index = i === 0 ? i : i - 1\n        topHeader = headings[index]\n        return true\n      }\n      if (i === headings.length - 1) {\n        // This allows scrolling for the last heading on the page.\n        topHeader = headings[headings.length - 1]\n        return true\n      }\n    })\n    return topHeader\n  }\n\n  function updateUrlHashForHeader(headingsArray) {\n    const scrollTop = getScrollTop()\n    const topHeader = getTopHeader(headingsArray, scrollTop)\n    const isPageBottomMode = getIsPageBottomMode()\n    if ((!topHeader || scrollTop < 5) && !isPageBottomMode) {\n      if (!(window.location.hash === \"#\" || window.location.hash === \"\")) {\n        window.history.pushState(null, null, \"#\")\n      }\n    } else if (topHeader && !isPageBottomMode) {\n      const newHash = `#${topHeader.id}`\n      if (window.location.hash !== newHash) {\n        window.history.pushState(null, null, newHash)\n      }\n    }\n  }\n\n  return {\n    enableTocAnimation,\n    disableTocAnimation,\n    render,\n    updateToc,\n    getCurrentlyHighlighting,\n    getTopHeader,\n    getScrollTop,\n    updateUrlHashForHeader,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}